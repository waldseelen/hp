const CACHE_VERSION="2.0.0",CACHE_NAME="portfolio-v2.0.0",PERFORMANCE_CACHE="portfolio-performance-v2.0.0",API_CACHE="portfolio-api-v2.0.0",urlsToCache=["/","/offline/","/static/css/custom.css","/static/css/output.css","/static/js/main.js","/static/js/pwa.js","/static/js/performance.js","/static/js/theme-manager.js","/static/manifest.json","/blog/","/tools/","/contact/","/main/personal/","/main/ai/","/main/cybersecurity/","/main/useful/"],performanceUrls=["/api/performance/","/api/health/"],NOTIFICATION_CONFIG={badge:"/static/icons/badge-72x72.png",icon:"/static/icons/icon-192x192.png",tag:"portfolio-notification",requireInteraction:!1,silent:!1,vibrate:[200,100,200],actions:[{action:"view",title:"View",icon:"/static/icons/view-icon.png"},{action:"dismiss",title:"Dismiss",icon:"/static/icons/dismiss-icon.png"}]};async function syncContactForm(){try{const t=await openIndexedDB(),e=await getOfflineForms(t);for(const o of e)try{(await fetch("/contact/",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(o.data)})).ok&&await deleteOfflineForm(t,o.id)}catch(t){}}catch(t){}}function openIndexedDB(){return new Promise((t,e)=>{const o=indexedDB.open("PortfolioOfflineDB",1);o.onerror=()=>e(o.error),o.onsuccess=()=>t(o.result),o.onupgradeneeded=t=>{const e=t.target.result;e.objectStoreNames.contains("forms")||e.createObjectStore("forms",{keyPath:"id",autoIncrement:!0}),e.objectStoreNames.contains("performance")||e.createObjectStore("performance",{keyPath:"id",autoIncrement:!0}),e.objectStoreNames.contains("errors")||e.createObjectStore("errors",{keyPath:"id",autoIncrement:!0})}})}function getOfflineForms(t){return new Promise((e,o)=>{const n=t.transaction(["forms"],"readonly").objectStore("forms").getAll();n.onerror=()=>o(n.error),n.onsuccess=()=>e(n.result)})}function deleteOfflineForm(t,e){return new Promise((o,n)=>{const a=t.transaction(["forms"],"readwrite").objectStore("forms").delete(e);a.onerror=()=>n(a.error),a.onsuccess=()=>o()})}async function handleNotificationClick(t,e,o){await logNotificationInteraction(t||"clicked",o),"dismiss"!==t&&("view"!==t&&t?o.actions&&o.actions[t]&&await openUrlInClient(o.actions[t].url||e):await openUrlInClient(e))}async function openUrlInClient(t){const e=await self.clients.matchAll({type:"window",includeUncontrolled:!0});for(const o of e)if(o.url===t&&"focus"in o)return o.focus();if(self.clients.openWindow)return self.clients.openWindow(t)}async function logNotificationReceived(t){try{await fetch("/api/webpush/log/",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({event:"received",timestamp:Date.now(),data:t})})}catch(t){}}async function logNotificationInteraction(t,e){try{await fetch("/api/webpush/log/",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({event:t,timestamp:Date.now(),data:e})})}catch(t){}}self.addEventListener("install",t=>{t.waitUntil(caches.open(CACHE_NAME).then(t=>t.addAll(urlsToCache))),self.skipWaiting()}),self.addEventListener("activate",t=>{t.waitUntil(caches.keys().then(t=>Promise.all(t.map(t=>{if(t!==CACHE_NAME&&t!==PERFORMANCE_CACHE&&t!==API_CACHE)return caches.delete(t)})))),self.clients.claim()}),self.addEventListener("push",t=>{let e={};if(t.data)try{e=t.data.json()}catch(o){e={title:"Portfolio Update",body:t.data.text()||"You have a new notification"}}else e={title:"Portfolio Update",body:"You have a new notification"};const o={...NOTIFICATION_CONFIG,body:e.body||"New update available",icon:e.icon||NOTIFICATION_CONFIG.icon,badge:e.badge||NOTIFICATION_CONFIG.badge,image:e.image,data:{url:e.url||"/",timestamp:Date.now(),...e.data},tag:e.tag||NOTIFICATION_CONFIG.tag};e.actions&&Array.isArray(e.actions)&&(o.actions=e.actions.slice(0,2)),t.waitUntil(Promise.all([self.registration.showNotification(e.title||"Portfolio Update",o),logNotificationReceived(e)]))}),self.addEventListener("notificationclick",t=>{t.notification.close();const e=t.action,o=t.notification.data||{},n=o.url||"/";t.waitUntil(handleNotificationClick(e,n,o))}),self.addEventListener("notificationclose",t=>{const e=t.notification.data||{};t.waitUntil(logNotificationInteraction("closed",e))});const originalFetch=self.fetch;async function logApiPerformance(t,e,o,n){try{(e>100||o>=400)&&await originalFetch("/api/performance/",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({metric_type:"api_request",value:e,url:t,additional_data:{status:o,type:n,timestamp:Date.now()}})})}catch(t){}}async function networkFirstStrategy(t,e){try{const o=await fetch(t);return o.ok&&(await caches.open(e)).put(t,o.clone()),o}catch(e){const o=await caches.match(t);if(o)return o;throw e}}async function cacheFirstStrategy(t,e){const o=await caches.match(t);if(o)return o;try{const o=await fetch(t);return o.ok&&(await caches.open(e)).put(t,o.clone()),o}catch(e){if("document"===t.destination)return caches.match("/offline/")||caches.match("/");throw e}}async function staleWhileRevalidateStrategy(t,e){const o=await caches.match(t),n=fetch(t).then(o=>(o.ok&&caches.open(e).then(e=>e.put(t,o.clone())),o)).catch(()=>o);return o||n}async function syncPerformanceMetrics(){try{const t=await openIndexedDB(),e=await getStoredData(t,"performance");for(const o of e)try{(await fetch("/api/performance/",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(o.data)})).ok&&await deleteStoredData(t,"performance",o.id)}catch(t){}}catch(t){}}async function syncErrorLogs(){try{const t=await openIndexedDB(),e=await getStoredData(t,"errors");for(const o of e)try{(await fetch("/api/errors/",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(o.data)})).ok&&await deleteStoredData(t,"errors",o.id)}catch(t){}}catch(t){}}function getStoredData(t,e){return new Promise((o,n)=>{const a=t.transaction([e],"readonly").objectStore(e).getAll();a.onerror=()=>n(a.error),a.onsuccess=()=>o(a.result)})}function deleteStoredData(t,e,o){return new Promise((n,a)=>{const i=t.transaction([e],"readwrite").objectStore(e).delete(o);i.onerror=()=>a(i.error),i.onsuccess=()=>n()})}async function syncFormSubmissions(){try{const t=(await openFormDB()).transaction(["failed_forms"],"readwrite").objectStore("failed_forms"),e=await getAllFromStore(t);for(const o of e)try{(await fetch(o.url,{method:o.method,headers:o.headers,body:o.body})).ok&&(await deleteFromStore(t,o.id),self.registration.showNotification("Form Submitted",{body:"Your form has been submitted successfully!",icon:"/static/images/icons/icon-192.png",badge:"/static/images/icons/badge-72.png",tag:"form-success",data:{type:"form-success",formId:o.id}}))}catch(t){}}catch(t){throw t}}async function openFormDB(){return new Promise((t,e)=>{const o=indexedDB.open("FormSyncDB",1);o.onerror=()=>e(o.error),o.onsuccess=()=>t(o.result),o.onupgradeneeded=t=>{const e=t.target.result;if(!e.objectStoreNames.contains("failed_forms")){const t=e.createObjectStore("failed_forms",{keyPath:"id",autoIncrement:!0});t.createIndex("timestamp","timestamp",{unique:!1}),t.createIndex("url","url",{unique:!1})}}})}async function getAllFromStore(t){return new Promise((e,o)=>{const n=t.getAll();n.onerror=()=>o(n.error),n.onsuccess=()=>e(n.result)})}async function deleteFromStore(t,e){return new Promise((o,n)=>{const a=t.delete(e);a.onerror=()=>n(a.error),a.onsuccess=()=>o()})}async function addToStore(t,e){return new Promise((o,n)=>{const a=t.add(e);a.onerror=()=>n(a.error),a.onsuccess=()=>o(a.result)})}async function storeFailedForm(t){try{const e=(await openFormDB()).transaction(["failed_forms"],"readwrite").objectStore("failed_forms"),o={url:t.url,method:t.method,headers:t.headers,body:t.body,timestamp:Date.now(),retryCount:0};await addToStore(e,o),"sync"in self.registration&&await self.registration.sync.register("form-sync")}catch(t){}}async function handleFormSubmission(t){try{const e=await fetch(t.clone());if(e.ok)return e;throw new Error(`HTTP ${e.status}`)}catch(e){const o={url:t.url,method:t.method,headers:Object.fromEntries(t.headers.entries()),body:await t.clone().text()};return await storeFailedForm(o),new Response(JSON.stringify({success:!1,offline:!0,message:"Form will be submitted when connection is restored."}),{status:200,statusText:"Queued for sync",headers:{"Content-Type":"application/json"}})}}self.fetch=async function(t,e){const o=performance.now(),n="string"==typeof t?t:t.url;try{const a=await originalFetch.call(this,t,e),i=performance.now();return n.includes("/api/")&&logApiPerformance(n,i-o,a.status,"fetch"),a}catch(t){const e=performance.now();throw n.includes("/api/")&&logApiPerformance(n,e-o,0,"fetch-error"),t}},self.addEventListener("fetch",t=>{const{request:e}=t,o=new URL(e.url);if("POST"!==e.method||!(o.pathname.includes("/contact/")||o.pathname.includes("/api/")||e.headers.get("content-type")?.includes("application/x-www-form-urlencoded")||e.headers.get("content-type")?.includes("multipart/form-data")||e.headers.get("content-type")?.includes("application/json")))return"GET"!==e.method?fetch(e):void(o.pathname.startsWith("/api/")?t.respondWith(networkFirstStrategy(e,API_CACHE)):o.pathname.match(/\.(png|jpg|jpeg|gif|webp|avif|svg|ico)$/i)?t.respondWith(staleWhileRevalidateStrategy(e,CACHE_NAME)):o.pathname.startsWith("/static/")||o.pathname.match(/\.(css|js|woff2?|ttf|eot)$/i)?t.respondWith(cacheFirstStrategy(e,CACHE_NAME)):"document"===e.destination?t.respondWith(staleWhileRevalidateStrategy(e,CACHE_NAME)):t.respondWith(cacheFirstStrategy(e,CACHE_NAME)));t.respondWith(handleFormSubmission(e))}),self.addEventListener("sync",t=>{switch(t.tag){case"contact-form":t.waitUntil(syncContactForm());break;case"performance-metrics":t.waitUntil(syncPerformanceMetrics());break;case"error-logs":t.waitUntil(syncErrorLogs())}}),self.addEventListener("sync",t=>{"form-sync"===t.tag&&t.waitUntil(syncFormSubmissions())});
//# sourceMappingURL=sw.min.js.map
//# sourceMappingURL=sw.min.js.map