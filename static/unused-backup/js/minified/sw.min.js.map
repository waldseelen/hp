{"version":3,"file":"sw.min.js","names":["CACHE_VERSION","CACHE_NAME","PERFORMANCE_CACHE","API_CACHE","urlsToCache","performanceUrls","NOTIFICATION_CONFIG","badge","icon","tag","requireInteraction","silent","vibrate","actions","action","title","async","syncContactForm","db","openIndexedDB","forms","getOfflineForms","form","fetch","method","headers","body","JSON","stringify","data","ok","deleteOfflineForm","id","error","Promise","resolve","reject","request","indexedDB","open","onerror","onsuccess","result","onupgradeneeded","event","target","objectStoreNames","contains","createObjectStore","keyPath","autoIncrement","transaction","objectStore","getAll","delete","handleNotificationClick","url","logNotificationInteraction","openUrlInClient","clients","self","matchAll","type","includeUncontrolled","client","focus","openWindow","logNotificationReceived","timestamp","Date","now","addEventListener","waitUntil","caches","then","cache","addAll","skipWaiting","keys","cacheNames","all","map","cacheName","claim","notificationData","json","text","notificationOptions","image","Array","isArray","slice","registration","showNotification","notification","close","originalFetch","logApiPerformance","duration","status","metric_type","value","additional_data","networkFirstStrategy","response","put","clone","cachedResponse","match","cacheFirstStrategy","destination","staleWhileRevalidateStrategy","fetchPromise","c","catch","syncPerformanceMetrics","metrics","getStoredData","metric","deleteStoredData","syncErrorLogs","errors","storeName","syncFormSubmissions","store","openFormDB","getAllFromStore","formData","deleteFromStore","formId","createIndex","unique","addToStore","add","storeFailedForm","formRecord","retryCount","sync","register","handleFormSubmission","Error","Object","fromEntries","entries","Response","success","offline","message","statusText","init","startTime","performance","call","this","endTime","includes","URL","pathname","get","startsWith","respondWith"],"sources":["0"],"sourcesContent":["// Service Worker for PWA with Push Notifications\r\nconst CACHE_VERSION = '2.0.0';\r\nconst CACHE_NAME = `portfolio-v${CACHE_VERSION}`;\r\nconst PERFORMANCE_CACHE = `portfolio-performance-v${CACHE_VERSION}`;\r\nconst API_CACHE = `portfolio-api-v${CACHE_VERSION}`;\r\n\r\nconst urlsToCache = [\r\n    '/',\r\n    '/offline/',\r\n    '/static/css/custom.css',\r\n    '/static/css/output.css',\r\n    '/static/js/main.js',\r\n    '/static/js/pwa.js',\r\n    '/static/js/performance.js',\r\n    '/static/js/theme-manager.js',\r\n    '/static/manifest.json',\r\n    '/blog/',\r\n    '/tools/',\r\n    '/contact/',\r\n    '/main/personal/',\r\n    '/main/ai/',\r\n    '/main/cybersecurity/',\r\n    '/main/useful/',\r\n];\r\n\r\n// Performance monitoring URLs to cache\r\nconst performanceUrls = [\r\n    '/api/performance/',\r\n    '/api/health/',\r\n];\r\n\r\n// Notification configuration\r\nconst NOTIFICATION_CONFIG = {\r\n    badge: '/static/icons/badge-72x72.png',\r\n    icon: '/static/icons/icon-192x192.png',\r\n    tag: 'portfolio-notification',\r\n    requireInteraction: false,\r\n    silent: false,\r\n    vibrate: [200, 100, 200],\r\n    actions: [\r\n        {\r\n            action: 'view',\r\n            title: 'View',\r\n            icon: '/static/icons/view-icon.png'\r\n        },\r\n        {\r\n            action: 'dismiss',\r\n            title: 'Dismiss',\r\n            icon: '/static/icons/dismiss-icon.png'\r\n        }\r\n    ]\r\n};\r\n\r\n// Install event\r\nself.addEventListener('install', (event) => {\r\n    event.waitUntil(\r\n        caches.open(CACHE_NAME)\r\n            .then((cache) => {\r\n                console.log('Opened cache');\r\n                return cache.addAll(urlsToCache);\r\n            })\r\n    );\r\n    self.skipWaiting();\r\n});\r\n\r\n// Basic fetch handler removed - using advanced fetch handler below with intelligent routing\r\n\r\n// Activate event\r\nself.addEventListener('activate', (event) => {\r\n    event.waitUntil(\r\n        caches.keys().then((cacheNames) => {\r\n            return Promise.all(\r\n                cacheNames.map((cacheName) => {\r\n                    if (cacheName !== CACHE_NAME && \r\n                        cacheName !== PERFORMANCE_CACHE && \r\n                        cacheName !== API_CACHE) {\r\n                        console.log('Deleting old cache:', cacheName);\r\n                        return caches.delete(cacheName);\r\n                    }\r\n                })\r\n            );\r\n        })\r\n    );\r\n    self.clients.claim();\r\n});\r\n\r\n// Background sync removed - consolidated with enhanced sync handler below\r\n\r\nasync function syncContactForm() {\r\n    // Handle offline form submissions when back online\r\n    try {\r\n        const db = await openIndexedDB();\r\n        const forms = await getOfflineForms(db);\r\n        \r\n        for (const form of forms) {\r\n            try {\r\n                const response = await fetch('/contact/', {\r\n                    method: 'POST',\r\n                    headers: {\r\n                        'Content-Type': 'application/json',\r\n                    },\r\n                    body: JSON.stringify(form.data)\r\n                });\r\n                \r\n                if (response.ok) {\r\n                    await deleteOfflineForm(db, form.id);\r\n                    console.log('Offline form synced successfully');\r\n                }\r\n            } catch (error) {\r\n                console.error('Failed to sync form:', error);\r\n            }\r\n        }\r\n    } catch (error) {\r\n        console.error('Background sync failed:', error);\r\n    }\r\n}\r\n\r\nfunction openIndexedDB() {\r\n    return new Promise((resolve, reject) => {\r\n        const request = indexedDB.open('PortfolioOfflineDB', 1);\r\n        \r\n        request.onerror = () => reject(request.error);\r\n        request.onsuccess = () => resolve(request.result);\r\n        \r\n        request.onupgradeneeded = (event) => {\r\n            const db = event.target.result;\r\n            if (!db.objectStoreNames.contains('forms')) {\r\n                db.createObjectStore('forms', { keyPath: 'id', autoIncrement: true });\r\n            }\r\n            if (!db.objectStoreNames.contains('performance')) {\r\n                db.createObjectStore('performance', { keyPath: 'id', autoIncrement: true });\r\n            }\r\n            if (!db.objectStoreNames.contains('errors')) {\r\n                db.createObjectStore('errors', { keyPath: 'id', autoIncrement: true });\r\n            }\r\n        };\r\n    });\r\n}\r\n\r\nfunction getOfflineForms(db) {\r\n    return new Promise((resolve, reject) => {\r\n        const transaction = db.transaction(['forms'], 'readonly');\r\n        const store = transaction.objectStore('forms');\r\n        const request = store.getAll();\r\n        \r\n        request.onerror = () => reject(request.error);\r\n        request.onsuccess = () => resolve(request.result);\r\n    });\r\n}\r\n\r\nfunction deleteOfflineForm(db, id) {\r\n    return new Promise((resolve, reject) => {\r\n        const transaction = db.transaction(['forms'], 'readwrite');\r\n        const store = transaction.objectStore('forms');\r\n        const request = store.delete(id);\r\n        \r\n        request.onerror = () => reject(request.error);\r\n        request.onsuccess = () => resolve();\r\n    });\r\n}\r\n\r\n// ==========================================================================\r\n// PUSH NOTIFICATION HANDLERS\r\n// ==========================================================================\r\n\r\n// Push event - handle incoming push notifications\r\nself.addEventListener('push', (event) => {\r\n    console.log('[SW] Push received:', event);\r\n    \r\n    let notificationData = {};\r\n    \r\n    if (event.data) {\r\n        try {\r\n            notificationData = event.data.json();\r\n        } catch (error) {\r\n            console.error('[SW] Error parsing push data:', error);\r\n            notificationData = {\r\n                title: 'Portfolio Update',\r\n                body: event.data.text() || 'You have a new notification',\r\n            };\r\n        }\r\n    } else {\r\n        notificationData = {\r\n            title: 'Portfolio Update',\r\n            body: 'You have a new notification',\r\n        };\r\n    }\r\n    \r\n    const notificationOptions = {\r\n        ...NOTIFICATION_CONFIG,\r\n        body: notificationData.body || 'New update available',\r\n        icon: notificationData.icon || NOTIFICATION_CONFIG.icon,\r\n        badge: notificationData.badge || NOTIFICATION_CONFIG.badge,\r\n        image: notificationData.image,\r\n        data: {\r\n            url: notificationData.url || '/',\r\n            timestamp: Date.now(),\r\n            ...notificationData.data\r\n        },\r\n        tag: notificationData.tag || NOTIFICATION_CONFIG.tag\r\n    };\r\n    \r\n    // Override actions if provided\r\n    if (notificationData.actions && Array.isArray(notificationData.actions)) {\r\n        notificationOptions.actions = notificationData.actions.slice(0, 2); // Max 2 actions\r\n    }\r\n    \r\n    event.waitUntil(\r\n        Promise.all([\r\n            self.registration.showNotification(\r\n                notificationData.title || 'Portfolio Update', \r\n                notificationOptions\r\n            ),\r\n            logNotificationReceived(notificationData)\r\n        ])\r\n    );\r\n});\r\n\r\n// Notification click handler\r\nself.addEventListener('notificationclick', (event) => {\r\n    console.log('[SW] Notification clicked:', event);\r\n    \r\n    event.notification.close();\r\n    \r\n    const action = event.action;\r\n    const notificationData = event.notification.data || {};\r\n    const url = notificationData.url || '/';\r\n    \r\n    event.waitUntil(\r\n        handleNotificationClick(action, url, notificationData)\r\n    );\r\n});\r\n\r\n// Notification close handler\r\nself.addEventListener('notificationclose', (event) => {\r\n    console.log('[SW] Notification closed:', event);\r\n    \r\n    const notificationData = event.notification.data || {};\r\n    \r\n    event.waitUntil(\r\n        logNotificationInteraction('closed', notificationData)\r\n    );\r\n});\r\n\r\nasync function handleNotificationClick(action, url, data) {\r\n    // Log the interaction\r\n    await logNotificationInteraction(action || 'clicked', data);\r\n    \r\n    if (action === 'dismiss') {\r\n        return; // Just close, don't navigate\r\n    }\r\n    \r\n    // Handle different actions\r\n    if (action === 'view' || !action) {\r\n        await openUrlInClient(url);\r\n    } else if (data.actions && data.actions[action]) {\r\n        await openUrlInClient(data.actions[action].url || url);\r\n    }\r\n}\r\n\r\nasync function openUrlInClient(url) {\r\n    const clients = await self.clients.matchAll({\r\n        type: 'window',\r\n        includeUncontrolled: true\r\n    });\r\n    \r\n    // Check if any client is already open with the URL\r\n    for (const client of clients) {\r\n        if (client.url === url && 'focus' in client) {\r\n            return client.focus();\r\n        }\r\n    }\r\n    \r\n    // Open new window/tab\r\n    if (self.clients.openWindow) {\r\n        return self.clients.openWindow(url);\r\n    }\r\n}\r\n\r\nasync function logNotificationReceived(data) {\r\n    try {\r\n        await fetch('/api/webpush/log/', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n            },\r\n            body: JSON.stringify({\r\n                event: 'received',\r\n                timestamp: Date.now(),\r\n                data: data\r\n            })\r\n        });\r\n    } catch (error) {\r\n        console.error('[SW] Failed to log notification received:', error);\r\n    }\r\n}\r\n\r\nasync function logNotificationInteraction(action, data) {\r\n    try {\r\n        await fetch('/api/webpush/log/', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n            },\r\n            body: JSON.stringify({\r\n                event: action,\r\n                timestamp: Date.now(),\r\n                data: data\r\n            })\r\n        });\r\n    } catch (error) {\r\n        console.error('[SW] Failed to log notification interaction:', error);\r\n    }\r\n}\r\n\r\n// ==========================================================================\r\n// PERFORMANCE MONITORING\r\n// ==========================================================================\r\n\r\n// Performance monitoring for fetch requests\r\nconst originalFetch = self.fetch;\r\nself.fetch = async function(request, init) {\r\n    const startTime = performance.now();\r\n    const url = typeof request === 'string' ? request : request.url;\r\n    \r\n    try {\r\n        const response = await originalFetch.call(this, request, init);\r\n        const endTime = performance.now();\r\n        \r\n        // Log performance data for API calls\r\n        if (url.includes('/api/')) {\r\n            logApiPerformance(url, endTime - startTime, response.status, 'fetch');\r\n        }\r\n        \r\n        return response;\r\n    } catch (error) {\r\n        const endTime = performance.now();\r\n        \r\n        // Log failed requests\r\n        if (url.includes('/api/')) {\r\n            logApiPerformance(url, endTime - startTime, 0, 'fetch-error');\r\n        }\r\n        \r\n        throw error;\r\n    }\r\n};\r\n\r\nasync function logApiPerformance(url, duration, status, type) {\r\n    try {\r\n        // Only log if duration is significant or there's an error\r\n        if (duration > 100 || status >= 400) {\r\n            await originalFetch('/api/performance/', {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Content-Type': 'application/json',\r\n                },\r\n                body: JSON.stringify({\r\n                    metric_type: 'api_request',\r\n                    value: duration,\r\n                    url: url,\r\n                    additional_data: {\r\n                        status: status,\r\n                        type: type,\r\n                        timestamp: Date.now()\r\n                    }\r\n                })\r\n            });\r\n        }\r\n    } catch (error) {\r\n        console.error('[SW] Failed to log API performance:', error);\r\n    }\r\n}\r\n\r\n// ==========================================================================\r\n// ADVANCED CACHING STRATEGIES\r\n// ==========================================================================\r\n\r\n// Unified fetch handler with intelligent routing, caching strategies, and form sync\r\nself.addEventListener('fetch', (event) => {\r\n    const { request } = event;\r\n    const url = new URL(request.url);\r\n    \r\n    // Handle form submissions with background sync\r\n    if (request.method === 'POST' && \r\n        (url.pathname.includes('/contact/') || \r\n         url.pathname.includes('/api/') ||\r\n         request.headers.get('content-type')?.includes('application/x-www-form-urlencoded') ||\r\n         request.headers.get('content-type')?.includes('multipart/form-data') ||\r\n         request.headers.get('content-type')?.includes('application/json'))) {\r\n        \r\n        event.respondWith(handleFormSubmission(request));\r\n        return;\r\n    }\r\n    \r\n    // Skip other non-GET requests for caching (but handle them normally)\r\n    if (request.method !== 'GET') {\r\n        return fetch(request);\r\n    }\r\n    \r\n    // Intelligent routing based on URL patterns and resource types\r\n    if (url.pathname.startsWith('/api/')) {\r\n        // API requests: Network-first strategy with cache fallback\r\n        event.respondWith(networkFirstStrategy(request, API_CACHE));\r\n    } else if (url.pathname.match(/\\.(png|jpg|jpeg|gif|webp|avif|svg|ico)$/i)) {\r\n        // Images: Stale-while-revalidate strategy for optimal loading\r\n        event.respondWith(staleWhileRevalidateStrategy(request, CACHE_NAME));\r\n    } else if (url.pathname.startsWith('/static/') || url.pathname.match(/\\.(css|js|woff2?|ttf|eot)$/i)) {\r\n        // Static assets (CSS, JS, fonts): Cache-first strategy\r\n        event.respondWith(cacheFirstStrategy(request, CACHE_NAME));\r\n    } else if (request.destination === 'document') {\r\n        // HTML documents: Stale-while-revalidate for fresh content with fast loading\r\n        event.respondWith(staleWhileRevalidateStrategy(request, CACHE_NAME));\r\n    } else {\r\n        // Default fallback: Cache-first with network fallback\r\n        event.respondWith(cacheFirstStrategy(request, CACHE_NAME));\r\n    }\r\n});\r\n\r\nasync function networkFirstStrategy(request, cacheName) {\r\n    try {\r\n        const response = await fetch(request);\r\n        \r\n        if (response.ok) {\r\n            const cache = await caches.open(cacheName);\r\n            cache.put(request, response.clone());\r\n        }\r\n        \r\n        return response;\r\n    } catch (error) {\r\n        console.log('[SW] Network failed, trying cache:', error);\r\n        const cachedResponse = await caches.match(request);\r\n        \r\n        if (cachedResponse) {\r\n            return cachedResponse;\r\n        }\r\n        \r\n        throw error;\r\n    }\r\n}\r\n\r\nasync function cacheFirstStrategy(request, cacheName) {\r\n    const cachedResponse = await caches.match(request);\r\n    \r\n    if (cachedResponse) {\r\n        return cachedResponse;\r\n    }\r\n    \r\n    try {\r\n        const response = await fetch(request);\r\n        \r\n        if (response.ok) {\r\n            const cache = await caches.open(cacheName);\r\n            cache.put(request, response.clone());\r\n        }\r\n        \r\n        return response;\r\n    } catch (error) {\r\n        console.error('[SW] Cache first strategy failed:', error);\r\n        \r\n        // Return offline page for navigation requests\r\n        if (request.destination === 'document') {\r\n            return caches.match('/offline/') || caches.match('/');\r\n        }\r\n        \r\n        throw error;\r\n    }\r\n}\r\n\r\nasync function staleWhileRevalidateStrategy(request, cacheName) {\r\n    const cachedResponse = await caches.match(request);\r\n    \r\n    const fetchPromise = fetch(request).then(response => {\r\n        if (response.ok) {\r\n            const cache = caches.open(cacheName);\r\n            cache.then(c => c.put(request, response.clone()));\r\n        }\r\n        return response;\r\n    }).catch(() => {\r\n        // Network failed, return cached version if available\r\n        return cachedResponse;\r\n    });\r\n    \r\n    // Return cached version immediately if available, otherwise wait for network\r\n    return cachedResponse || fetchPromise;\r\n}\r\n\r\n// ==========================================================================\r\n// COMPREHENSIVE BACKGROUND SYNC\r\n// ==========================================================================\r\n\r\n// Unified background sync handler for all sync events\r\nself.addEventListener('sync', (event) => {\r\n    console.log('[SW] Background sync triggered:', event.tag);\r\n    \r\n    switch (event.tag) {\r\n        case 'contact-form':\r\n            event.waitUntil(syncContactForm());\r\n            break;\r\n        case 'performance-metrics':\r\n            event.waitUntil(syncPerformanceMetrics());\r\n            break;\r\n        case 'error-logs':\r\n            event.waitUntil(syncErrorLogs());\r\n            break;\r\n        default:\r\n            console.log('[SW] Unknown sync tag:', event.tag);\r\n    }\r\n});\r\n\r\nasync function syncPerformanceMetrics() {\r\n    try {\r\n        const db = await openIndexedDB();\r\n        const metrics = await getStoredData(db, 'performance');\r\n        \r\n        for (const metric of metrics) {\r\n            try {\r\n                const response = await fetch('/api/performance/', {\r\n                    method: 'POST',\r\n                    headers: {\r\n                        'Content-Type': 'application/json',\r\n                    },\r\n                    body: JSON.stringify(metric.data)\r\n                });\r\n                \r\n                if (response.ok) {\r\n                    await deleteStoredData(db, 'performance', metric.id);\r\n                }\r\n            } catch (error) {\r\n                console.error('[SW] Failed to sync performance metric:', error);\r\n            }\r\n        }\r\n    } catch (error) {\r\n        console.error('[SW] Performance metrics sync failed:', error);\r\n    }\r\n}\r\n\r\nasync function syncErrorLogs() {\r\n    try {\r\n        const db = await openIndexedDB();\r\n        const errors = await getStoredData(db, 'errors');\r\n        \r\n        for (const error of errors) {\r\n            try {\r\n                const response = await fetch('/api/errors/', {\r\n                    method: 'POST',\r\n                    headers: {\r\n                        'Content-Type': 'application/json',\r\n                    },\r\n                    body: JSON.stringify(error.data)\r\n                });\r\n                \r\n                if (response.ok) {\r\n                    await deleteStoredData(db, 'errors', error.id);\r\n                }\r\n            } catch (error) {\r\n                console.error('[SW] Failed to sync error log:', error);\r\n            }\r\n        }\r\n    } catch (error) {\r\n        console.error('[SW] Error logs sync failed:', error);\r\n    }\r\n}\r\n\r\n// Helper functions for IndexedDB operations\r\nfunction getStoredData(db, storeName) {\r\n    return new Promise((resolve, reject) => {\r\n        const transaction = db.transaction([storeName], 'readonly');\r\n        const store = transaction.objectStore(storeName);\r\n        const request = store.getAll();\r\n        \r\n        request.onerror = () => reject(request.error);\r\n        request.onsuccess = () => resolve(request.result);\r\n    });\r\n}\r\n\r\nfunction deleteStoredData(db, storeName, id) {\r\n    return new Promise((resolve, reject) => {\r\n        const transaction = db.transaction([storeName], 'readwrite');\r\n        const store = transaction.objectStore(storeName);\r\n        const request = store.delete(id);\r\n        \r\n        request.onerror = () => reject(request.error);\r\n        request.onsuccess = () => resolve();\r\n    });\r\n}\r\n\r\n\r\n// =============================================================================\r\n// BACKGROUND SYNC FOR OFFLINE FORM SUBMISSIONS\r\n// =============================================================================\r\n\r\n// Register for background sync when forms fail to submit\r\nself.addEventListener('sync', event => {\r\n    if (event.tag === 'form-sync') {\r\n        console.log('[SW] Background sync triggered for forms');\r\n        event.waitUntil(syncFormSubmissions());\r\n    }\r\n});\r\n\r\n// Sync failed form submissions\r\nasync function syncFormSubmissions() {\r\n    try {\r\n        const db = await openFormDB();\r\n        const transaction = db.transaction(['failed_forms'], 'readwrite');\r\n        const store = transaction.objectStore('failed_forms');\r\n        const forms = await getAllFromStore(store);\r\n        \r\n        for (const formData of forms) {\r\n            try {\r\n                const response = await fetch(formData.url, {\r\n                    method: formData.method,\r\n                    headers: formData.headers,\r\n                    body: formData.body\r\n                });\r\n                \r\n                if (response.ok) {\r\n                    // Success - remove from IndexedDB\r\n                    await deleteFromStore(store, formData.id);\r\n                    console.log('[SW] Form synced successfully:', formData.id);\r\n                    \r\n                    // Show success notification\r\n                    self.registration.showNotification('Form Submitted', {\r\n                        body: 'Your form has been submitted successfully!',\r\n                        icon: '/static/images/icons/icon-192.png',\r\n                        badge: '/static/images/icons/badge-72.png',\r\n                        tag: 'form-success',\r\n                        data: { type: 'form-success', formId: formData.id }\r\n                    });\r\n                } else {\r\n                    console.log('[SW] Form sync failed:', response.status);\r\n                }\r\n            } catch (error) {\r\n                console.log('[SW] Form sync error:', error);\r\n            }\r\n        }\r\n    } catch (error) {\r\n        console.error('[SW] Background sync error:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n// IndexedDB helper functions for form storage\r\nasync function openFormDB() {\r\n    return new Promise((resolve, reject) => {\r\n        const request = indexedDB.open('FormSyncDB', 1);\r\n        \r\n        request.onerror = () => reject(request.error);\r\n        request.onsuccess = () => resolve(request.result);\r\n        \r\n        request.onupgradeneeded = event => {\r\n            const db = event.target.result;\r\n            if (!db.objectStoreNames.contains('failed_forms')) {\r\n                const store = db.createObjectStore('failed_forms', { keyPath: 'id', autoIncrement: true });\r\n                store.createIndex('timestamp', 'timestamp', { unique: false });\r\n                store.createIndex('url', 'url', { unique: false });\r\n            }\r\n        };\r\n    });\r\n}\r\n\r\nasync function getAllFromStore(store) {\r\n    return new Promise((resolve, reject) => {\r\n        const request = store.getAll();\r\n        request.onerror = () => reject(request.error);\r\n        request.onsuccess = () => resolve(request.result);\r\n    });\r\n}\r\n\r\nasync function deleteFromStore(store, id) {\r\n    return new Promise((resolve, reject) => {\r\n        const request = store.delete(id);\r\n        request.onerror = () => reject(request.error);\r\n        request.onsuccess = () => resolve();\r\n    });\r\n}\r\n\r\nasync function addToStore(store, data) {\r\n    return new Promise((resolve, reject) => {\r\n        const request = store.add(data);\r\n        request.onerror = () => reject(request.error);\r\n        request.onsuccess = () => resolve(request.result);\r\n    });\r\n}\r\n\r\n// Store failed form submission for later sync\r\nasync function storeFailedForm(formData) {\r\n    try {\r\n        const db = await openFormDB();\r\n        const transaction = db.transaction(['failed_forms'], 'readwrite');\r\n        const store = transaction.objectStore('failed_forms');\r\n        \r\n        const formRecord = {\r\n            url: formData.url,\r\n            method: formData.method,\r\n            headers: formData.headers,\r\n            body: formData.body,\r\n            timestamp: Date.now(),\r\n            retryCount: 0\r\n        };\r\n        \r\n        await addToStore(store, formRecord);\r\n        \r\n        // Register for background sync\r\n        if ('sync' in self.registration) {\r\n            await self.registration.sync.register('form-sync');\r\n            console.log('[SW] Background sync registered for form');\r\n        }\r\n        \r\n    } catch (error) {\r\n        console.error('[SW] Failed to store form for sync:', error);\r\n    }\r\n}\r\n\r\n// Enhanced form submission handler\r\nasync function handleFormSubmission(request) {\r\n    try {\r\n        // Try to submit the form normally\r\n        const response = await fetch(request.clone());\r\n        \r\n        if (response.ok) {\r\n            return response;\r\n        } else {\r\n            throw new Error(`HTTP ${response.status}`);\r\n        }\r\n    } catch (error) {\r\n        console.log('[SW] Form submission failed, storing for sync:', error);\r\n        \r\n        // Store the failed form submission\r\n        const formData = {\r\n            url: request.url,\r\n            method: request.method,\r\n            headers: Object.fromEntries(request.headers.entries()),\r\n            body: await request.clone().text()\r\n        };\r\n        \r\n        await storeFailedForm(formData);\r\n        \r\n        // Return a custom response indicating offline mode\r\n        return new Response(JSON.stringify({\r\n            success: false,\r\n            offline: true,\r\n            message: 'Form will be submitted when connection is restored.'\r\n        }), {\r\n            status: 200,\r\n            statusText: 'Queued for sync',\r\n            headers: { 'Content-Type': 'application/json' }\r\n        });\r\n    }\r\n}"],"mappings":"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","ignoreList":[]}